{
  "hash": "0d9afaf317a354cb0964251d70d5dfe2",
  "result": {
    "markdown": "---\ntitle: \"{{< fa regular folder-open >}} Diretórios\"\nlang: pt-BR\n---\n\nOs comandos a seguir são essenciais na gestão de diretórios no Linux. Importante lembrar que a maioria dos diretórios dentro do Linux irão requerer permissão de superusuário para que possam ser modificados. Esses diretórios em um servidor são de responsabilidade do adminstrador do sistema e estarão fora do escopo de permissões de um usuário, por esse motivo abordaremos operações comuns que podem ser realizadas na nossa pasta de usuário `/home`.\n\n::: callout-note\nAs funções não serão abordadas em detalhes, serão apresentados os usos de caso mais comuns, para maiores informações de cada função acesse a sua respectiva ***man page*** usando o terminal.\n:::\n\n## Diretório de Trabalho\n\n`pwd` - *print working directory*\n\n\n```{default}\npwd\n```\n\n\n    /home/paulo/Documents/SandBox\n\n## Listando conteúdo de diretórios\n\n`ls` - *list directory contents*\n\n![](images/ls.png){fig-align=\"center\" width=\"700\"}\n\n\nO terminal pode apresentar os resultados com esquemas de cores diferentes a depender do tipo de shell sendo utilizado. De maneira geral, diretórios são destacados com cores (azul neste caso), diferenciando-os de arquivos de texto (branco), imagens (roxo), e arquivos com permissão de execução ou outros formatos especiais (verde).\n\nUtilizando opções é possível modificar o tipo de saída. Por padrão o comando `ls` não exibe arquivos ou diretórios ocultos, isto pode ser alterado utilizando a opção `a`. A opção `l` lista o conteúdo em um formato mais longo e detalhado. É possível combinar opções ou simplesmente listá-las uma após a outra, lembrando sempre de consultar a documentação para o uso de `-` ou `--`. Por exemplo, os dois comandos abaixo retornam o mesmo resultado.\n\n\n```{default}\nls -l -a\nls -la\n```\n\n\n![](images/ls-la.png){fig-align=\"center\" width=\"700\"}\n\nAlgumas opções também possuem uma descrição literal, sendo mais fáceis de lembrar, embora requeiram mais digitação. A opção `a` poderia ser substituida por `all`, essas não podem ser concatenadas e devem ser declaradas separadamente. Nem todas as opções possuem uma forma alternativa no padrão GNU, é sempre bom checar a documentação. O comando abaixo retorna a mesma saída do último que rodamos acima.\n\n\n```{default}\nls -l --all\n```\n\n\n\nÉ possível listar arquivos específicos passando como argumento para o `ls` a extensão do arquivo ou parte do nome por exemplo. O comando abaixo lista todos os arquivos com extensão `.R`, o `*` é um caractere de **expressão regular** que indica para o comando que o objetivo é buscar qualquer nome de arquivo desde que este termine com a extensão desejada. \n\n\n```{default}\nls *.R\n```\n\n\n![](images/ls-ext.png){fig-align=\"center\" width=\"700\"}\n\n```{default}\nls *map*\n```\n\n\n![](images/ls-map.png){fig-align=\"center\" width=\"700\"}\n\nExpressões regulares são muito úteis e utilizadas constantemente em diversos comandos de terminal, falaremos mais em detalhes ao longo do curso. Na imagem abaixo[^1] seguem alguns coringas que podem ser utilizados para otimizar buscas por arquivos e diretórios no sistema.\n\n[^1]: Haeder _et al._, 2010. LPI Linux Certification, Third Edition, O'Reilly Media.p. 101.\n\n![](images/wildcards.png){fig-align=\"center\" height=\"700\"}\n\n## Criando diretórios\n\n`mkdir` [opções] _diretórios_: cria um ou mais diretórios, você precisa ter permissão de escrita no diretório destino.\n\n\n```{default}\nmkdir meu_diretorio\n```\n\n\n![](images/mkdir_a.png){fig-align=\"center\" width=\"700\"}\n\nDuas das opções mais utilizadas com o `mkdir` são `-m` e `-p`. A opção `-m`define o **modo de acesso** do diretório a ser criado. A opção `-p` cria diretórios superiores, caso eles não existam.\n\n\n```{default}\n# a opção -m 444 define modo de somente leitura para o novo diretório\nmkdir -m 444 minha_pasta \n```\n\n\n![](images/mkdir_mode.png){fig-align=\"center\" width=\"700\"}\n\nObserve as diferenças nas permissões de arquivos para as duas pastas. `d` refere-se a _directory_ , `r` a _read_, `w` a _write_ e `x` a _execution_. Estas três são as classes de acesso/permissão de arquivos e diretórios no Linux, leitura, escrita e execução. O bloco de acesso é formado por três trincas representando as permissões para `Usuário`, `Grupo` e `Outro` respectivamente. O usuário que é o dono do arquivo, o grupo proprietário do arquivo (todo usuário do Linux pertence a um grupo no sistema) e o acesso para outros usuários.\n\nÉ possível criar múltiplos diretórios com um único comando, basta separar os nomes dos diretórios por espaços. \n\n\n```{default}\nmkdir folder_a folder_b\n```\n\n\n\n![](images/mkdir_multi.png){fig-align=\"center\" width=\"700\"}\n\nTambém é possível a criação de árvores de diretório com a opção `-p` para a criação dos diretórios superiores caso estes ainda não tenham sido criados.\n\n\n```{default}\nmkdir -p dir1/dir2/dir3\n```\n\n\n\n![](images/mkdir_tree.png){fig-align=\"center\" width=\"700\"}\n\nEmbora criar diretórios possa parecer uma tarefa trivial e que pode ser realizada de maneira visual em qualquer navegador de arquivos de um SO, quando falamos de estruturas de diretórios mais complexas com muitos níveis o terminal é uma enorme ajuda. Por exemplo, imagine que tenhamos um projeto com uma estrutura bem definida de diretórios e subdiretórios, visualmente teríamos que criar cada pasta individualmente, quando no terminal em um único comando toda a estrutura é criada. Veja o exemplo.\n\n\n\n```{default}\nmkdir -p meu_projeto/{data/{raw,clean},imagens,relatorios/{pdf,html}}\n\n```\n\n\n![](images/mkdir_proj_tree.png){fig-align=\"center\" width=\"800\"}\n\nNeste caso, passamos para o comando a nossa estrutura na forma de `diretorio/{subdiretório}`, separando os múltiplos subdiretórios por `,`, caso um subdiretório contenha outros subdiretórios, o padrão é o mesmo como pode ser observado no exemplo.\n\n## Copiando, Movendo e Deletando diretórios\n\n### Copiando\n\n`cp` [opções] _arquivo_fonte_ _arquivo_destino_: copia arquivos\n\n`cp` [opções] _arquivo_fonte_ _diretório_destino_: copia arquivos para um diretório específico\n\n\n```{default}\ncp -r folder_a folder_b\n```\n\n\n![](images/cp_dir.png){fig-align=\"center\" width=\"700\"}\n\nNeste exemplo a pasta `folder_a` é copiada para a pasta `folder_b`. A opção `-r` indica que a cópia é recursiva, ou seja, inclui também a pasta `folder_a`, sem o uso desta opção apenas o conteúdo da pasta é copiada, mas não a pasta em si. Essa opção é muito utilizada em todas as operações de modificação de diretórios que veremos a seguir.\n\nPara duplicar uma pasta o comando é o mesmo, observando apenas a mudança do nome da pasta destino.\n\n\n```{default}\ncp -r folder_a folder_c\n```\n\n\n### Movendo e Renomeando\n\n`mv` [opções] _fonte_ _destino_\n\nO comando `mv` é utilizando tanto para mover diretórios quanto para renomeá-los.\n\n\n```{default}\nmv dir1 dir_1\n```\n\n\n![](images/mv_dir.png){fig-align=\"center\" width=\"700\"}\n\n\n```{default}\nmv -i folder_a folder_b\n\n```\n\n\n![](images/mv_dir_2.png){fig-align=\"center\" width=\"700\"}\n\nNo primeiro exemplo, o diretório `dir1` foi renomeado para `dir_1`. No segundo exemplo o diretório `folder_a` foi movido para `folder_b`. A opção `-i` consulta interativamente o usuário antes de mover os arquivos, como neste caso já existia um outro diretório de mesmo nome na pasta destino, o terminal pergunta se o usuário gostaria de sobrescrever o diretório pré-existente. Após a confirmação o comando é executado.\n\n### Removendo diretórios\n\n`rm` [opções] _arquivos_\n\n\n```{default}\nrm -r folder_a\n```\n\n\n\n![](images/rm_dir.png){fig-aling=\"center\" width=\"700\"}\n\n:::{.callout-note}\n### Importante\n\nObserve o uso da opção `-r`, essa opção é necessária se a intenção é remover todos os arquivos e o próprio diretório. Sem esta opção os arquivos internos serão excluídos e o diretório será preservado.\n:::\n\n`rmdir` [opções] _diretórios_\n\nO comando `rmdir` também pode ser utilizado para excluir diretórios, entretanto, os diretórios precisam estar vazios. Uma combinação com a opção `-p` permite que diretórios superiores que também estejam vazios sejam removidos.\n\n\n```{default}\nrmdir -p meu_projeto/relatorios/html\n```\n\n\n![](images/rmdir.png){fig-aling=\"center\" width=\"700\"}\n\nObserve na estrutura dos diretórios, embora o comando emita uma mensagem de erro informando que a pasta `meu_projeto` não pode ser excluída por não estar vazia, ele remove com sucesso a pasta `html` vazia, e o diretório ascendente `relatorios`, vazio após a exclusão feita anteriormente. Esse comando é muito útil para remoção de estrutura de diretórios de forma automatizada.\n\n",
    "supporting": [
      "folders_files"
    ],
    "filters": [],
    "includes": {}
  }
}